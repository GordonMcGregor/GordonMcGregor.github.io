<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
        <title>Five Computers &middot; articles tagged "esl"</title>
        <link rel="shortcut icon" href="http://fivecomputers.com/favicon.ico" />
        <link href="http://fivecomputers.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Five Computers Atom Feed" />
                
        <link rel="stylesheet" href="http://fivecomputers.com/theme/css/screen.css" type="text/css" />
        <link rel="stylesheet" href="http://fivecomputers.com/theme/css/pygments.css" type="text/css" />


    </head>
    <body>
        <div id="header">
            <ul id="nav">
                <li class="ephemeral selected"><a href="http://fivecomputers.com/tag/esl.html">esl</a></li>
                <li><a href="http://fivecomputers.com">Home</a></li>
                <li><a href="http://fivecomputers.com/pages/about-gordon.html">About Gordon</a></li>
                <li><a href="http://fivecomputers.com/archives.html">Archives</a></li>
            </ul>
            <div class="header_box">
                <h1><a href="http://fivecomputers.com">Five Computers</a></h1>
            </div>
        </div>
        <div id="wrapper">
            <div id="content">
                <h4 class="date">Nov  6,  2008</h4>
                <div class="post">
                    <h2 class="title">
                        <a href="http://fivecomputers.com/where-are-they-now.html" rel="bookmark" title="Permanent Link to &quot;Where are they now?&quot;">Where are they now?</a>
                    </h2>
                    
                    <p><a href="http://fivecomputers.typepad.com/photos/uncategorized/2008/06/11/_s3t8496.jpg"><img height="426" border="0" width="640" alt="_s3t8496" title="_s3t8496" src="http://www.fivecomputers.com/images/2008/06/11/_s3t8496.jpg" style="margin: 0px 5px 5px 0px; display: block;" /></a></p>

<p>DAC started early with a Mentor sponsored breakfast at 7:30. Got to see a bit about some of their testbench automation tools that help steer coverage to more interesting parts of the design. There are a few other companies here that have similar products. The aim is to move beyond user driven constrained random testing and let the tools help in solving the problem.</p>

<p>After that, I listened to Gary Smith on the state of the EDA industry. Highlights:</p>

<ul><li>It's all about the software</li>

<li>Threads are dead</li>

<li>C is finished to be replaced by some useful concurrent language - brush up on Occam I say</li>

<li>Verification is a solved problem and will be automated - don't bother being a verification engineer</li>

<li>Almost 38% of companies roll their own EDA tools</li></ul>

<p>His talk made for an interesting start to the day, at least.</p>

<p>I spent the rest of the day attending various sessions and tool demos, which I'll write more about later. I've been surprised how low attendance is. There are a lot of people from the tool companies in their booths, but not many customers for them to talk to - and that was on Monday, the free attendance day when there aren't that many technical sessions or other distractions. </p>

<p>The Open Verification Methodology(OVM) is a hot item this year, with many sessions discussing issues around use and interoperability. Many vendors are showing products or claiming compatibility with this new standard. SystemVerilog is the other dominant theme though SystemC still has some traction. The last time I was at DAC SystemC was the new kid on the block that everyone was expecting to take over the world, not so much any more and it has settled into a system level modeling niche. </p>

<p>The disturbing thing I am seeing is how little progress has been made in the last decade in the ESL tool industry. Many years ago I was working on ARM926 designs that were not on the bleeding edge, even then. Today, many ESL companies are still just showing support for ARM9 or being excited about performance of their ARM7 models. That's at least 2 or 3 cycles behind the latest processor technologies and a huge leap in tool complexity to keep up. Synthesis capacities are rising much slower than the process technologies, tools companies are stalling out, reimplementing the same technologies to support systemC, systemVerilog or what ever the new hot language or methodology is, without apparently making any significant progress.</p>

<p>The other problem that the ESL companies face is the lack of models for their particular product line. Many seem to be falling into the same trap - expecting customer demand to dictate which models to develop. But that isn't going to work - the systems designers need the models right around when they decide they need the models. There is no lead time. There certainly isn't the 6 months to 1 year lead time it takes to find the right ESL company, negotiate and convince them to start creating a model, get the team together and write and verify the model, then deliver it back to the system architect. When the architect wants the model, there might be a 1 week lead time. Maybe a month, before serious work needs to start. The whole investigation better be mostly finished in 6 months. ESL companies need to seed their model libraries in anticipation of customer need. If they wait for the customer, they'll always be too late to be any use at all and keep going round that loop. In spite of that glaring hole, ESL is another hot ticket at DAC this year. Software design and implementation continues to increase in cost and complexity and HW/SW co-design companies are proliferating as a result.</p>

<p>With the apparent dearth of progress and lack of useful model or up-to-date models, I'm not too surprised that almost 40% of companies are looking inwards for their EDA tools. Might also explain where everyone is this year, too. </p>

<p>The one bright light in the ESL space is that although many of the tools and methodologies haven't changed much in the last 5 years, they do seem to have moved on from being all smoke and mirrors and snake oil to perhaps actually working. So maybe things haven't changed, they've just become real.</p>

                    <div class="clear"></div>
                    <p>There are <a href="http://fivecomputers.com/where-are-they-now.html#disqus_thread">comments</a>.</p>
                    <div class="info">
                        <a href="http://fivecomputers.com/where-are-they-now.html">posted at 12:00 P</a>&nbsp;&middot;&nbsp;<a href="http://fivecomputers.com/category/11.html" rel="tag">11</a>                                                <div class="tags">
                            <a href="http://fivecomputers.com/tag/eda.html">eda</a>
                            <a href="http://fivecomputers.com/tag/esl.html" class="selected">esl</a>
                        </div>                        
                    </div>
                    <div class="clear"></div>
                </div>

                <h4 class="date">Jun 20,  2008</h4>
                <div class="post">
                    <h2 class="title">
                        <a href="http://fivecomputers.com/a-somewhat-crazy-notion.html" rel="bookmark" title="Permanent Link to &quot;a somewhat crazy notion&quot;">a somewhat crazy notion</a>
                    </h2>
                    
                    <p><a title="Death Valley, after the storm by Gordon McGregor, on Flickr" href="http://www.flickr.com/photos/mcgregorphoto/358741765/"><img height="333" width="500" alt="Death Valley, after the storm" src="http://farm1.static.flickr.com/146/358741765_9ab4eeb321.jpg" /></a>

</p>

<p>Many ideas have been whirling around in my head since being at DAC. I've been inspired to learn some new things, starting with the <a href="http://www.ovmworld.org/">Open Verification Methodology</a> but also revisiting some of the Electronic System Level tools and flows that I've worked with in the past. I'm interested in exploring visualization techniques and tools and how they might be applied to verification and design. I'd also like to learn more about a few of the more interesting formal verification tools, like <a href="http://www.onespin-solutions.com">OneSpin 360 MV</a> and maybe explore what is possible with ESL tools like <a href="http://www.bluespec.com/products/index.htm">Bluespec's SystemVerilog</a> flow or the various other similar tools that are out there.</p>

<p>I have a difficult time learning things just for the sake of it, tending to be more driven by necessity rather than idle curiosity. I've been doing some work based around a small CPU core and started getting frustrated with the way the CPU was architected. This led me to start considering designing my own CPU, just for fun. Partly as a motivation to crack open a Hennessy &amp; Patterson book that I've been meaning to read for a few years, partly to see if I can do it, partly as a vehicle to hang all those other ideas upon.</p>

<p>I've been looking around the web, browsing on <a href="http://opencores.org/">OpenCores</a> and finding humbling projects, such as <a href="http://homebrewcpu.org/">HomebrewCPU,</a> which is a Minix-compatible CPU entirely constructed from discrete gates. You can even browse the web pages that it is serving or telnet in to it! To my way of thinking, that is slightly nuts - impressive, but nuts all the same - five wire-wrapped boards to debug. My <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/m/McGregor:Gordon.html">background is in FPGAs</a> and that seems the perfect technology for this sort of exploration - I'm also thinking along the way that I might be able to play with synthesisable verification or FPGA enhanced verification/ emulation as well as possibly using this as a platform for a reconfigurable architecture. Lots of ideas, potential and possibilities. It will also give me a chance to re-engage with FPGA technologies and learn about more about the state of those tools. The various tools are getting to a fairly mature point and a simple pipelined CPU shouldn't require too much work but still be complex enough to do interesting things with.</p>

<p>I've been looking at <a href="http://www.xilinx.com">Xilinx</a> and <a href="http://www.altera.com">Altera </a>to get an understanding of their current tool flows and trying to work out language support and maturity - which would be the best option for systemVerilog, where the best simulation options are and that kind of thing. No real conclusions yet, but both have trial versions of what appears to be a complete tool chain, so I will probably drive a small example through both flows as a pipe cleaner.</p>

<p>Then of course there are the more fundamental religious issues - CISC or RISC, what ISA to use. Roll my own, pick up an already defined but open architecture, or something in between? I'm looking for suggestions in this respect - I know ARM are quite litigious when it comes to cloning their ISA, so I'll be avoiding that, but <a href="http://www.opensparc.net/">OpenSPARC</a> might well be a good option. Any other suggestions? I'm not sure if the early MIPS ISAs are cloneable without problems? Maybe I could go really back to my roots and implement a <a href="http://en.wikipedia.org/wiki/Zx81">Z80 architecture</a>. The advantage of picking on an existing ISA is that the tools come mostly for free. While porting gas and gcc to my own ISA could also be an interesting experiment and learning experience, it would probably be more of a distraction than I want.</p>

<p>I am a fan of the Python language and tend to write most of my <a href="http://gordonmcgregor.blogspot.com/2008/03/flickr-set-parser-for-gpsvisualizer.html">personal projects</a> in it. As a result, I'm intrigued by the potential for writing the core in Python, using some of the available extensions and libraries. Two packages seem to already exist, <a href="http://myhdl.jandecaluwe.com/doku.php">MyHDL</a> and <a href="http://pyhvl.sourceforge.net/">PyHVL</a>. MyHDL is Python extension to let you express parallel behaviour that can then be automatically translated to verilog or VHDL. PyHVL provides the other piece of the Python puzzle, enabling high-level verification in Python. So potentially I could do the design and verification in Python then drive through into an FPGA flow for implementation. <a href="http://www.coolverification.com/2008/06/ovm-world-summi.html">JL</a> jokingly mentioned the potential for an OVM port to Python but maybe it isn't such a crazy notion. The thing that Python is fantastic for is expressing complex ideas quickly and without a lot of fuss or housekeeping. From the verification perspective it seems to be a perfect match as I can focus more on the testing, and less on the language. I'm a bit more skeptical about using it on the design side but I think it might be worth a look.</p>

<p>To kick things off, I found the description for a <a href="http://www.csie.ntu.edu.tw/~b92029/data/EXP/mcpu-doc.pdf">minimal CPU</a> on opencores. This is a really basic 8-bit processor, 4 op codes, couple of registers and a very simple, small architecture, yet it can still do some useful function. This evening I wrote a Python ISS for it, just to prove out some ideas. Took about an hour to get a working cycle-based ISS together for the architecture. Of course, immediately the next thing you need is an assembler and that was fairly easy to put together in Python too. Nothing particularly complex, but a two pass assembler that supports labels and constants and generates code that runs on the core. I'm able to assemble and run the example greatest common divisor (Dijkstra's algorithm) described in the paper and it has given me a good indication of the direction to go. So far, my couple of hour project can assemble and execute the following code:</p>

<blockquote><p><span style="font-size: 0.8em;">start:<br />&nbsp; &nbsp; NOR allone&nbsp; &nbsp;&nbsp; &nbsp;; akku == 0<br />&nbsp; &nbsp; NOR b<br />&nbsp; &nbsp; ADD one&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; akku = -b<br /><br />&nbsp; &nbsp; ADD a&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; ; akku = a - b<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; ; Carry set when akku &gt;= 0<br />&nbsp; &nbsp; JCC neg<br /><br />&nbsp; &nbsp; STA a<br /><br />&nbsp; &nbsp; ADD allone&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp; JCC end&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; A=0 ? -&gt; end, result in b<br /><br />&nbsp; &nbsp; JCC start<br /><br />neg:<br />&nbsp; &nbsp; NOR zero<br />&nbsp; &nbsp; ADD one&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Akku = -Akku<br /><br />&nbsp; &nbsp; STA b<br />&nbsp; &nbsp; JCC start&nbsp; &nbsp;&nbsp; &nbsp; ; carry not altered<br /><br />end:<br />&nbsp; &nbsp; JCC end<br /><br />a: 10&nbsp; ; a &amp; b are the two values to consider<br />b: 30<br /><br />allone: 0xff&nbsp; ; various constants<br />zero:&nbsp; &nbsp;0<br />one:&nbsp; &nbsp; 1</span></p></blockquote>

<p>Next step is to describe this trivial core in a synthesisable form and see how I get on running it through one or two FPGA flows. A few tests and some verification could be useful too! For FPGAs I'm much more used to the general <em>suck it and see </em>style of testing that is the norm. Synthesize, place and route and see if it works. In the last several years I've been working on much larger ASICs so have certainly seen the value of more robust verification and I think FPGA technology has probably spent too much time as the wild frontier of design robustness and testing. As this project progresses I want to explore what the best balance is for testing and how the test environments can use the FPGA to accelerate testing along the way.</p>

<p>So plenty of things up in the air but I think this could be fun.</p>

<p><br /></p>

                    <div class="clear"></div>
                    <p>There are <a href="http://fivecomputers.com/a-somewhat-crazy-notion.html#disqus_thread">comments</a>.</p>
                    <div class="info">
                        <a href="http://fivecomputers.com/a-somewhat-crazy-notion.html">posted at 12:00 P</a>&nbsp;&middot;&nbsp;<a href="http://fivecomputers.com/category/20.html" rel="tag">20</a>                                                <div class="tags">
                            <a href="http://fivecomputers.com/tag/cpu.html">cpu</a>
                            <a href="http://fivecomputers.com/tag/dac.html">dac</a>
                            <a href="http://fivecomputers.com/tag/eda.html">eda</a>
                            <a href="http://fivecomputers.com/tag/esl.html" class="selected">esl</a>
                            <a href="http://fivecomputers.com/tag/software.html">software</a>
                            <a href="http://fivecomputers.com/tag/verification.html">verification</a>
                        </div>                        
                    </div>
                    <div class="clear"></div>
                </div>

                <div class="clear"></div>
                <div id="footer">
                    <p>
                    <a href="https://twitter.com/GordonMcGregor">Twitter @GordonMcGregor</a>
                    &middot;
                    <a class="atom" href="http://fivecomputers.com/feeds/all.atom.xml">RSS Feed</a>
                </div>
            </div>
            <div class="clear"></div>
        </div>
    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-42678190-1");
    pageTracker._trackPageview();
    } catch(err) {}</script>
<script type="text/javascript">
    var disqus_shortname = 'fivecomputers';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
    </body>
</html>