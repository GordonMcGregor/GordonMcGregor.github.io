<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Five Computers</title><link href="http://fivecomputers.com/" rel="alternate"></link><link href="http://fivecomputers.com/feeds/17.atom.xml" rel="self"></link><id>http://fivecomputers.com/</id><updated>2008-06-17T00:00:00-05:00</updated><entry><title>visual commitment</title><link href="http://fivecomputers.com/visual-commitment.html" rel="alternate"></link><updated>2008-06-17T00:00:00-05:00</updated><author><name>GordonMcGregor</name></author><id>tag:fivecomputers.com,2008-06-17:visual-commitment.html</id><summary type="html">&lt;p&gt;&lt;a title="graphic by Gordon McGregor, on Flickr" href="http://www.flickr.com/photos/mcgregorphoto/2514642239/"&gt;&lt;img width="500" height="333" alt="graphic" src="http://farm3.static.flickr.com/2006/2514642239_13100d1a20.jpg" /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;I've had an on again/ off again interest in visualization tools to enhance design and verification for many years. I've written log file parsers to show data in a more friendly way to enhance debug, or TCL/Tk widgets that demonstrate activity on bus ports of a SystemC AMBA switch model. Tools that at first glance might seem somewhat pointless visual trinkets can really enhance debug, by letting the brain search for patterns more easily within data. For example, with the bus switch, it was visually easy to see which bus wasn't getting any traffic, which could have been extracted from a log, but would have required more thought. Patterns of burstiness or busyness can also be seen quite easily. Similar results can usually be achieved with grep or clever regular expressions, but I find I end up having to keep a lot more data in my head, which pushes out the brainpower I might apply to actually working on the real problem.&lt;/p&gt;

&lt;p&gt;Well written visualisations present the data in a more accessible way, letting you get to the problems more quickly. A good example of these from the recent DAC are a couple of OCP tools by &lt;a href="http://www.duolog.com/"&gt;Duolog&lt;/a&gt;. The tools present typical OCP information in a more easily interpretable way, &lt;a href="http://www.duolog.com/products/ocp-toolkit/conductor"&gt;colouring related transactions in a log file&lt;/a&gt;, or &lt;a href="http://www.duolog.com/products/ocp-toolkit/tracker"&gt;showing bus bandwidth&lt;/a&gt;. It is much simpler to trace a series of transactions this way, or find buses that are being starved or overloaded. The information could have been directly extracted from the log file by the user, but the visualisations make things easier and quicker.&lt;/p&gt;

&lt;p&gt;I've been playing around with&amp;nbsp; &lt;a href="http://www.flashdevelop.org/"&gt;Flash&lt;/a&gt; and also just started reading about the &lt;a href="http://processing.org/"&gt;Processing&lt;/a&gt; language over the weekend. Co-incidentally, I happened across these &lt;a href="http://vis.cs.ucdavis.edu/~ogawa/codeswarm/"&gt;visualisations of version control commits&lt;/a&gt; for several large projects, written in Processing. These give a good indication of how visualisations can show a lot of very complex data in a more accessible way. &lt;a href="http://www.vimeo.com/1093745"&gt;The Python visualisation&lt;/a&gt; was particularly interesting to show how few contributers there were until an explosion of contributions around the year 2000 wander on to the stage.&lt;/p&gt;

&lt;p&gt;As our SoC designs keep getting larger, I believe that more accessible means to interpret the verification and design data and results will be needed, beyond just waveforms and log traces. I would be interested to see what the ebb and flow of check-ins look like for a complex, modern SoC. We tend to think that hardware design is just the same as software design by another name, but you might start to see structural differences in how the code and modifications organise themselves. &lt;/p&gt;

&lt;p&gt;The Python case shows one leader, banging away on their own, suddenly joined en mass when the code base becomes popular. SoCs will also probably demonstrate Conway's Law visually, mirroring the organisational structure that put the design together. Pairs of verification and design engineers working together, sub-assemblies, clustering around organisational and functional boundaries. The vast majority of changes would be much more localised than you see in a large software project such as Python. Quite possibly other software projects fall along similar modular designs but it would be instructive to see the visualisations side by side - perhaps with the organisational (or lack of) human structure overlaid.&lt;/p&gt;</summary><category term="dac"></category></entry></feed>