<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Five Computers</title><link href="http://fivecomputers.com/" rel="alternate"></link><link href="http://fivecomputers.com/feeds/20.atom.xml" rel="self"></link><id>http://fivecomputers.com/</id><updated>2012-04-20T00:00:00-05:00</updated><entry><title>Simple web server</title><link href="http://fivecomputers.com/simple-web-server.html" rel="alternate"></link><updated>2012-04-20T00:00:00-05:00</updated><author><name>GordonMcGregor</name></author><id>tag:fivecomputers.com,2012-04-20:simple-web-server.html</id><summary type="html">&lt;p&gt;Ever find you need to implement a web server or provide some web pages on a local network? Maybe you don't have an Apache server up and running or don't want to go to the trouble of configuring it. I've found this with &lt;a href="http://www.naturaldocs.org/"&gt;Natural Docs&lt;/a&gt; documentation, where the tools will generate a bunch of .html files that you can read locally if you are on the machine where they are generated. &lt;a href="http://www.fivecomputers.com/2012/04/systemverilog-support-in-pygments.html"&gt;Pygments&lt;/a&gt; also will generate html formatted files that you might want to serve. However, you might want to make them accessible to a small team. Here is a quick trick that can make this task very simple. Python ships with a basic HTTP server module. You can get it up and running, serving files from a given directory down with the following command:&lt;/p&gt;

&lt;pre&gt;
python -m SimpleHTTPServer
&lt;/pre&gt;

&lt;p&gt;and that's all there is to it! The default port will be 8000, but you can provide a different port on the command line (just add the port number after the SimpleHTTPServer - any number above reserved range of 0-1024 will work. The server will be accessible to any machines that can see that port on the machine it is running on. The server won't handle a high load and isn't particular secure, so I wouldn't make it available to the general public. But if you need to serve some pages quickly and simply, to a small number of users within a private network, this can be a really fast way to get to that point. If and when the load becomes an issue, or security concerns are important, then a heavyweight server like Apache is a much better choice.&lt;/p&gt;

&lt;p&gt;Once the server is up and running you access it via a web browser at http://machine_name:8000 File paths are all relative to the directory the server is running in. If there is an index.html in that directory, it will be loaded by default when you access the server at that URL.&lt;/p&gt;</summary><category term="software"></category><category term="thingumyjigs"></category></entry><entry><title>show my pc</title><link href="http://fivecomputers.com/show-my-pc.html" rel="alternate"></link><updated>2008-08-20T00:00:00-05:00</updated><author><name>GordonMcGregor</name></author><id>tag:fivecomputers.com,2008-08-20:show-my-pc.html</id><summary type="html">&lt;p style="text-align: center;"&gt;&lt;a href="http://www.flickr.com/photos/52043707@N00/2773340946/"&gt;&lt;img src="http://farm4.static.flickr.com/3081/2773340946_6e4b085c39.jpg" height="334" width="500" alt="frisco shore" /&gt;&lt;/a&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;I'm on an extended work trip at the moment. My wife and I have been keeping touch with &lt;a href="http://www.skype.com"&gt;Skype&lt;/a&gt;, using the video conferencing and VoIP on a daily basis. It's great to be able to see each other and talk without speaking in to a phone. I've come to realise the value of a good microphone and proper speaker setup, as well as a decent camera. In general it has been really effective, at least within the US. Typically fast, quite clear audio and good picture quality.&lt;/p&gt;

&lt;p&gt;We also needed to look at some documents on the computer. Skype doesn't have a remote desktop sharing option and we had some problems getting the Windows Live Messenger working to share screens and there would be the added difficulty of sharing from Windows XP to my Mac (I'd have been using a VM Fusion Windows session). Instead, we tried &lt;a href="http://www.showmypc.com"&gt;http://www.showmypc.com&lt;/a&gt;. I was impressed how easy it was to set up, just download an application and run it (a bit of trust required there). Then there is a password that you share with the user at the other end of the link and you are connected. Under the hood it sets up a VNC session via an SSH server, but from an end user perspective, all you need is the password to connect. It was fast, easy to use and worked well Windows XP &amp;lt;-&amp;gt; OS X. They have options where you set up your own SSH server in the middle, rather than trusting their servers, but I think you have to pay for that option. In general, it was surprisingly easy and effective. We were able to still have the Skype video call running in parallel too.&lt;/p&gt;

&lt;p&gt;The picture of the beach? That's the Outer Banks in North Carolina - about 4 hours from where I'm working at the moment. I &lt;a href="http://flickr.com/photos/mcgregorphoto/sets/72157606793809724/show/"&gt;took the opportunity&lt;/a&gt; to go there for the weekend and camp out in the sand. Traveling for work isn't ideal but I try to make the most of the places I do get to go, in particular seeing the area or taking advantage of museums and art galleries I wouldn't normally have the chance to visit. In that respect, I tend to disagree with Grant Martin's sentiment over &lt;a href="http://www.chipdesignmag.com/martins/2008/07/07/not-taking-a-country-for-granted/"&gt;on his blog&lt;/a&gt;. I've still been able to disconnect on business trips and see a bit of the local culture. Two weeks ago I saw a &lt;a href="http://www.ncartmuseum.org/collections/highlights/european/french/1770-1900/011_lrg.shtml"&gt;Monet&lt;/a&gt; at the North Carolina museum of art. This weekend I was in the Outer Banks. I think you have to push yourself a bit to really take advantage of the opportunities that might be there, but it can certainly be done. For every business trip I've been on in the last few years, I've really worked to get to at least one museum or art gallery, just to make it worthwhile.&lt;/p&gt;</summary><category term="software"></category></entry><entry><title>a somewhat crazy notion</title><link href="http://fivecomputers.com/a-somewhat-crazy-notion.html" rel="alternate"></link><updated>2008-06-20T00:00:00-05:00</updated><author><name>GordonMcGregor</name></author><id>tag:fivecomputers.com,2008-06-20:a-somewhat-crazy-notion.html</id><summary type="html">&lt;p&gt;&lt;a title="Death Valley, after the storm by Gordon McGregor, on Flickr" href="http://www.flickr.com/photos/mcgregorphoto/358741765/"&gt;&lt;img height="333" width="500" alt="Death Valley, after the storm" src="http://farm1.static.flickr.com/146/358741765_9ab4eeb321.jpg" /&gt;&lt;/a&gt;

&lt;/p&gt;

&lt;p&gt;Many ideas have been whirling around in my head since being at DAC. I've been inspired to learn some new things, starting with the &lt;a href="http://www.ovmworld.org/"&gt;Open Verification Methodology&lt;/a&gt; but also revisiting some of the Electronic System Level tools and flows that I've worked with in the past. I'm interested in exploring visualization techniques and tools and how they might be applied to verification and design. I'd also like to learn more about a few of the more interesting formal verification tools, like &lt;a href="http://www.onespin-solutions.com"&gt;OneSpin 360 MV&lt;/a&gt; and maybe explore what is possible with ESL tools like &lt;a href="http://www.bluespec.com/products/index.htm"&gt;Bluespec's SystemVerilog&lt;/a&gt; flow or the various other similar tools that are out there.&lt;/p&gt;

&lt;p&gt;I have a difficult time learning things just for the sake of it, tending to be more driven by necessity rather than idle curiosity. I've been doing some work based around a small CPU core and started getting frustrated with the way the CPU was architected. This led me to start considering designing my own CPU, just for fun. Partly as a motivation to crack open a Hennessy &amp;amp; Patterson book that I've been meaning to read for a few years, partly to see if I can do it, partly as a vehicle to hang all those other ideas upon.&lt;/p&gt;

&lt;p&gt;I've been looking around the web, browsing on &lt;a href="http://opencores.org/"&gt;OpenCores&lt;/a&gt; and finding humbling projects, such as &lt;a href="http://homebrewcpu.org/"&gt;HomebrewCPU,&lt;/a&gt; which is a Minix-compatible CPU entirely constructed from discrete gates. You can even browse the web pages that it is serving or telnet in to it! To my way of thinking, that is slightly nuts - impressive, but nuts all the same - five wire-wrapped boards to debug. My &lt;a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/m/McGregor:Gordon.html"&gt;background is in FPGAs&lt;/a&gt; and that seems the perfect technology for this sort of exploration - I'm also thinking along the way that I might be able to play with synthesisable verification or FPGA enhanced verification/ emulation as well as possibly using this as a platform for a reconfigurable architecture. Lots of ideas, potential and possibilities. It will also give me a chance to re-engage with FPGA technologies and learn about more about the state of those tools. The various tools are getting to a fairly mature point and a simple pipelined CPU shouldn't require too much work but still be complex enough to do interesting things with.&lt;/p&gt;

&lt;p&gt;I've been looking at &lt;a href="http://www.xilinx.com"&gt;Xilinx&lt;/a&gt; and &lt;a href="http://www.altera.com"&gt;Altera &lt;/a&gt;to get an understanding of their current tool flows and trying to work out language support and maturity - which would be the best option for systemVerilog, where the best simulation options are and that kind of thing. No real conclusions yet, but both have trial versions of what appears to be a complete tool chain, so I will probably drive a small example through both flows as a pipe cleaner.&lt;/p&gt;

&lt;p&gt;Then of course there are the more fundamental religious issues - CISC or RISC, what ISA to use. Roll my own, pick up an already defined but open architecture, or something in between? I'm looking for suggestions in this respect - I know ARM are quite litigious when it comes to cloning their ISA, so I'll be avoiding that, but &lt;a href="http://www.opensparc.net/"&gt;OpenSPARC&lt;/a&gt; might well be a good option. Any other suggestions? I'm not sure if the early MIPS ISAs are cloneable without problems? Maybe I could go really back to my roots and implement a &lt;a href="http://en.wikipedia.org/wiki/Zx81"&gt;Z80 architecture&lt;/a&gt;. The advantage of picking on an existing ISA is that the tools come mostly for free. While porting gas and gcc to my own ISA could also be an interesting experiment and learning experience, it would probably be more of a distraction than I want.&lt;/p&gt;

&lt;p&gt;I am a fan of the Python language and tend to write most of my &lt;a href="http://gordonmcgregor.blogspot.com/2008/03/flickr-set-parser-for-gpsvisualizer.html"&gt;personal projects&lt;/a&gt; in it. As a result, I'm intrigued by the potential for writing the core in Python, using some of the available extensions and libraries. Two packages seem to already exist, &lt;a href="http://myhdl.jandecaluwe.com/doku.php"&gt;MyHDL&lt;/a&gt; and &lt;a href="http://pyhvl.sourceforge.net/"&gt;PyHVL&lt;/a&gt;. MyHDL is Python extension to let you express parallel behaviour that can then be automatically translated to verilog or VHDL. PyHVL provides the other piece of the Python puzzle, enabling high-level verification in Python. So potentially I could do the design and verification in Python then drive through into an FPGA flow for implementation. &lt;a href="http://www.coolverification.com/2008/06/ovm-world-summi.html"&gt;JL&lt;/a&gt; jokingly mentioned the potential for an OVM port to Python but maybe it isn't such a crazy notion. The thing that Python is fantastic for is expressing complex ideas quickly and without a lot of fuss or housekeeping. From the verification perspective it seems to be a perfect match as I can focus more on the testing, and less on the language. I'm a bit more skeptical about using it on the design side but I think it might be worth a look.&lt;/p&gt;

&lt;p&gt;To kick things off, I found the description for a &lt;a href="http://www.csie.ntu.edu.tw/~b92029/data/EXP/mcpu-doc.pdf"&gt;minimal CPU&lt;/a&gt; on opencores. This is a really basic 8-bit processor, 4 op codes, couple of registers and a very simple, small architecture, yet it can still do some useful function. This evening I wrote a Python ISS for it, just to prove out some ideas. Took about an hour to get a working cycle-based ISS together for the architecture. Of course, immediately the next thing you need is an assembler and that was fairly easy to put together in Python too. Nothing particularly complex, but a two pass assembler that supports labels and constants and generates code that runs on the core. I'm able to assemble and run the example greatest common divisor (Dijkstra's algorithm) described in the paper and it has given me a good indication of the direction to go. So far, my couple of hour project can assemble and execute the following code:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;&lt;span style="font-size: 0.8em;"&gt;start:&lt;br /&gt;&amp;nbsp; &amp;nbsp; NOR allone&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;; akku == 0&lt;br /&gt;&amp;nbsp; &amp;nbsp; NOR b&lt;br /&gt;&amp;nbsp; &amp;nbsp; ADD one&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;; akku = -b&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; ADD a&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; ; akku = a - b&lt;br /&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; ; Carry set when akku &amp;gt;= 0&lt;br /&gt;&amp;nbsp; &amp;nbsp; JCC neg&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; STA a&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; ADD allone&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&lt;br /&gt;&amp;nbsp; &amp;nbsp; JCC end&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;; A=0 ? -&amp;gt; end, result in b&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; JCC start&lt;br /&gt;&lt;br /&gt;neg:&lt;br /&gt;&amp;nbsp; &amp;nbsp; NOR zero&lt;br /&gt;&amp;nbsp; &amp;nbsp; ADD one&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp;; Akku = -Akku&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; STA b&lt;br /&gt;&amp;nbsp; &amp;nbsp; JCC start&amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp; ; carry not altered&lt;br /&gt;&lt;br /&gt;end:&lt;br /&gt;&amp;nbsp; &amp;nbsp; JCC end&lt;br /&gt;&lt;br /&gt;a: 10&amp;nbsp; ; a &amp;amp; b are the two values to consider&lt;br /&gt;b: 30&lt;br /&gt;&lt;br /&gt;allone: 0xff&amp;nbsp; ; various constants&lt;br /&gt;zero:&amp;nbsp; &amp;nbsp;0&lt;br /&gt;one:&amp;nbsp; &amp;nbsp; 1&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Next step is to describe this trivial core in a synthesisable form and see how I get on running it through one or two FPGA flows. A few tests and some verification could be useful too! For FPGAs I'm much more used to the general &lt;em&gt;suck it and see &lt;/em&gt;style of testing that is the norm. Synthesize, place and route and see if it works. In the last several years I've been working on much larger ASICs so have certainly seen the value of more robust verification and I think FPGA technology has probably spent too much time as the wild frontier of design robustness and testing. As this project progresses I want to explore what the best balance is for testing and how the test environments can use the FPGA to accelerate testing along the way.&lt;/p&gt;

&lt;p&gt;So plenty of things up in the air but I think this could be fun.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</summary><category term="cpu"></category><category term="dac"></category><category term="eda"></category><category term="esl"></category><category term="software"></category><category term="verification"></category></entry></feed>