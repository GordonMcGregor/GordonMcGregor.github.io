<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Five Computers</title><link href="http://fivecomputers.com/" rel="alternate"></link><link href="http://fivecomputers.com/feeds/28.atom.xml" rel="self"></link><id>http://fivecomputers.com/</id><updated>2008-08-28T00:00:00-05:00</updated><entry><title>Zerstreutheit and the hardware design flow</title><link href="http://fivecomputers.com/zerstreutheit-and-the-hardware-design-flow.html" rel="alternate"></link><updated>2008-08-28T00:00:00-05:00</updated><author><name>GordonMcGregor</name></author><id>tag:fivecomputers.com,2008-08-28:zerstreutheit-and-the-hardware-design-flow.html</id><summary type="html">&lt;div style="text-align: center;"&gt;
  &lt;a href="http://xkcd.com/303/"&gt;&lt;img src="http://imgs.xkcd.com/comics/compiling.png" width="413" height="360" /&gt;&lt;/a&gt;&lt;br /&gt;
&lt;/div&gt;

&lt;p&gt;Recently I've been &lt;a href="http://www-128.ibm.com/developerworks/java/library/j-ap09056/index.html"&gt;reading&lt;/a&gt; about the various open-source Continuous Integration servers that are available. &lt;a href="http://confluence.public.thoughtworks.org/display/CC/CI+Feature+Matrix"&gt;This chart&lt;/a&gt; gives a good feature comparision of many of the systems that are out there. &lt;a href="http://www.verilab.com" title="Verilab, Inc."&gt;We've&lt;/a&gt; been evaluating &lt;a href="http://cruisecontrol.sourceforge.net/"&gt;Cruise Control&lt;/a&gt; on some internal projects and generally trying to understand what the issues are with deploying a CI server on a hardware design project. One of the things I've been struggling with is the real, meaningful difference between continuous integration and the more typical &lt;a href="http://www.joelonsoftware.com/articles/fog0000000023.html"&gt;daily build&lt;/a&gt; and check-in smoke tests. Scheduled builds are often described as an &lt;a href="http://www.ibm.com/developerworks/java/library/j-ap03048/index.html?S_TACT=105AGX02&amp;amp;S_CMP=EDU"&gt;anti-pattern&lt;/a&gt; when considering CI, but as far as I can tell the only practical difference is in the frequency of the builds. Certainly, you have the potential to find out about a broken build more quickly with CI, hence it has less chance to impact other users. Also, you are always doing &lt;em&gt;useful&lt;/em&gt; work, rather than maybe re-running a version because no check-in has happened since the previous build. However, these distinctions of implementing CI are maybe more significant in the software world than for the typically longer build times found in hardware design projects. This then is the key point - build time is the significant factor in CI. The real benefit of using CI successfully is that you need to refine your processes to keep the build as quick as possible, striving for close to a &lt;a href="http://www.martinfowler.com/articles/continuousIntegration.html"&gt;10 minute turnaround time&lt;/a&gt;, to stop things getting backed up. The consequence of this is that the entire Checkout-Build-Test loop keeps being optimised and refined. This doesn't just help with automated processes but can significantly improve productivity for the developers who do these steps manually every day. That's great for the software world, but is it really practical for hardware design with the current compilers and the speed of typical RTL simulation? If not, is it worth even bothering with?&lt;/p&gt;

&lt;p&gt;The source control tools you choose can have a big impact on the first phase of the Checkout-Build-Test loop. When an update can take quarter an hour or longer, the source control system can become a significant productivity drain and stymie any chance of a quick turnaround. If merging changes, updating source and checking in a new revision takes hours, then there are real problems with the process and you certainly won't be doing multiple checkins per day (another fundamental CI process axiom is at minimum daily checkins for all developers, even more frequent is preferable). In &lt;a href="http://www.fivecomputers.com/2008/06/git---version-c.html"&gt;Linus' talk about Git&lt;/a&gt;, he describes being able to do a diff and merge on an entire kernel source tree (22k source files) in &lt;a href="http://git.or.cz/gitwiki/LinusTalk200705Transcript"&gt;less than a second&lt;/a&gt;. I've used other SCM environments with similar amounts of code, where an update might take 30 minutes. These sorts of differences can significantly change how you work. It isn't just a matter of the time that the particular automated task takes, but what the developer does while they are waiting, reading email, writing documentation, switching context to other distractions.&lt;/p&gt;

&lt;p&gt;Similarly, if the build takes half an hour or longer before it fails with a trivial syntax error, you'll have switched to something else and then have to try to mentally context switch back again to work on the problem. Each of these switches have an associated, measurable attention and productivity hit. Improving the build step can have a big impact on how you &lt;a href="http://www.43folders.com/2008/06/13/zerstreutheit-and-attention-management-cure"&gt;manage your attention&lt;/a&gt; and keep engaged with the development process. A faster turnaround can stave off the onset of &lt;em&gt;&lt;a href="http://www.43folders.com/comment/337830/literal-translation-Zerstreutheit"&gt;Zerstreutheit&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The final Test step is significantly slower for hardware design. Often this is used as a justification not to bother optimising the Checkout and Build phases, because they are comparatively much shorter. A multi-day or week long regression might fool you into thinking that an hour long build is relatively good. However, simulation &amp;amp; testing is the one step where the developer can be more out of the loop, with less impact. Typically, the user is not so tightly coupled into the testing loop, once the initial bugs are ironed out. Automation can certainly help here too, re-running failing tests with waveform dumping enabled or increased logging, to present a useful working environment for debug when the developer does come back to look at the fails.&lt;/p&gt;

&lt;p&gt;The point really is that there is still a significant advantage to be had in spending effort to optimize the SCM and compile stages in a development flow, to maximise designer productivity and attention, even if the simulation time is large. Also a &lt;a href="http://www.ibm.com/developerworks/java/library/j-ap11297/index.html?S_TACT=105AGX02&amp;amp;S_CMP=EDU"&gt;build pipeline&lt;/a&gt; can be used in the CI server to stage the build and testing feedback, to further mitigate the length of time that running tests takes. Deploying CI brings attention to how long these processes take and might help improve the entire development environment. Having fast enough tools can help the developers keep focused on what they are doing, without breaks for swordfights or reading email. Optimizing the build is still important, even in a hardware design environment, even when the runtime for regressions might be in terms of days or weeks. You might think the build process is only a comparatively small part of the overall runtime for a regression, but the designers spend most of their time looping through that comparatively small part.&lt;/p&gt;

&lt;p&gt;So what is the take away? Does CI have a place in a hardware design flow? I think that CI servers can certainly be used to manage running regressions and nightly builds. Smoke tests and scheduled build approaches can be controlled with most of the CI servers. However, the real continual building process required to move from scheduled builds to CI seems to be hard to map to hardware design, simply because of the length of time of the checkout/build/test loops. Tool improvements and generally faster hardware seems to be key to increasing the frequency of integration tests, at least for now. However, optimizing the interaction between the users and automated tools is a key and often overlooked part of developing an effective design flow, if you plan on using CI or not.&lt;/p&gt;</summary><category term="eda"></category><category term="software"></category></entry></feed>