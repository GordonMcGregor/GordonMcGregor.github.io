<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
        <title>Five Computers</title>
        <link rel="shortcut icon" href="http://fivecomputers.com/favicon.ico" />
        <link href="http://fivecomputers.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Five Computers Atom Feed" />
                
        <link rel="stylesheet" href="http://fivecomputers.com/theme/css/screen.css" type="text/css" />
        <link rel="stylesheet" href="http://fivecomputers.com/theme/css/pygments.css" type="text/css" />


    </head>
    <body>
        <div id="header">
            <ul id="nav">
                <li class="selected"><a href="http://fivecomputers.com">Home</a></li>
                <li><a href="http://fivecomputers.com/pages/about-gordon.html">About Gordon</a></li>
                <li><a href="http://fivecomputers.com/archives.html">Archives</a></li>
            </ul>
            <div class="header_box">
                <h1><a href="http://fivecomputers.com">Five Computers</a></h1>
            </div>
        </div>
        <div id="wrapper">
            <div id="content">
                <h4 class="date">Jun 26,  2008</h4>
                <div class="post">
                    <h2 class="title">
                        <a href="http://fivecomputers.com/git-version-control-done-right.html" rel="bookmark" title="Permanent Link to &quot;Git - version control done right&quot;">Git - version control done right</a>
                    </h2>
                    
                    <p><img width="500" height="334" src="http://farm3.static.flickr.com/2012/2573207802_7f55cbaab2.jpg" alt="concert hall" /></p>

<p>As I've started working on this small CPU project, one of the first decisions I've been considering has been which version control system to use. I've been a user of subversion for most of my personal projects for several years now and am currently using it at a client. As a result I'm quite familiar with the ins and outs of using it on a variety of sizes of projects. I've become more aware of distributed systems, such as <a href="http://git.or.cz/">Git</a> and <a href="http://www.selenic.com/mercurial/wiki/">Mercurial</a> over the last year, but haven't really been able to get my head around the advantages of them. In particular, the quote below from Linus Torvalds has been in the back of my mind.</p>

<p style="text-align: center;"><span style="font-size: 1.4em;"><em>"The slogan of Subversion for a while was 'CVS done right</em><em>', or something like that, and if you start with that kind of slogan, there's nowhere you can go. There is no way to do CVS right."</em></span></p>

<p style="text-align: right; font-size: 10px;">- Linus Torvalds</p>

<p>One of the main source control issues I've seen on several of the projects I've worked on has been the aversion to branches that most users have. Typically there is a big central source repository that everyone will check out from. You then develop in your own little world. When the particular piece of work is complete, you check it back in. Usually, there is a fairly high barrier or cost to those commits, with sets of test suites that you must pass before you can commit your code back to the central repository. The checks take hours to run and you can not check back in until your code passes all the tests. Otherwise everyone else is at risk. But I always found that if I was working on something non-trivial, I'd really like to make some progress and check point that half way, committing it in to just a local branch, then working on further. That would give me the confidence to make larger changes, safe in the knowledge I can revert back to a midway working point. That's what a branch would be for, after all, but not if they are hard to make and not if the commit cost is so high. So we never did that, working for days or weeks before committing any changes.</p>

<p>The second common frustration I've seen with a centralized repository occurs when two people are working closely together on a piece of the system. This happens to characterise almost every verification endeavor, for example. By common definition, the verification and design work should be done by two different people, just to get extra eyes on the spec. This avoids duplicating erroneous assumptions about the design and is fundamental to the whole process. As a consequence, we are almost always faced with the situation where changes need to be made by two or more people, in distinct parts of the code (e.g., testbench and rtl) but cannot be checked in because of mutual dependencies. The changes depend on each other and all the commit checks will fail for either change on its own. Various ways around this exist, disabling affected checks in the commit scripts, copying files into each others workspaces and other hacks. All because fundamentally the centralised server approach, with costly branches and high commit costs, doesn't really let this sort of work proceed in an effective way.</p>

<p>The third frustration is the general speed of the repository. Time to check things out, time to do merges, how long it takes to do a diff or an update. These operations can usually mean a break for coffee or a walk around while the tool fetches the changes, compares them and attempts to merge it all together. Compound that by working in remote sites or across multiple geographic locations.</p>

<p>Git claims to solve these problems and be a whole lot faster at the same time.</p>

<p>The key is in breaking away from a centralised server. The database is distributed to every developer. As a result, everyone works on their own branch by default. Making further branches is trivial, because they don't get sent to every other developer. Fewer issues with namespace collisions when naming a branch, no real concern about checking code in and someone else getting your partially finished work. Earlier today I'd listened to <a href="http://www.joelonsoftware.com/">Joel Spolsky</a> and <a href="http://www.codinghorror.com/">Jeff Atwood</a> <a href="http://itc.conversationsnetwork.org/shows/detail3710.html">talking</a> about the fact that Git makes branching trivial, but I didn't really understand why until I <a href="ttp://www.youtube.com/watch?v=4XpnKHJAok8">watched a really interesting presentation</a> from Linus Torvalds on the subject. It is supposed to be a talk about Git, but really he focuses almost exclusively on the advantages of a distributed repository. I'd initially thought the real advantage was the '<em>always available</em>' nature of a distributed repository, so that you could work on a plane or generally away from a network and still be able to check in, look at histories and all the things you normally need the central server access for. That's certainly part of the reason why it is interesting, but the branching and merging cost reduction that Git claims to offer is a much bigger deal.</p>

<p><object width="425" height="344">
  <param name="movie" value="http://www.youtube.com/v/4XpnKHJAok8&amp;hl=en" />
  <embed width="425" height="344" src="http://www.youtube.com/v/4XpnKHJAok8&amp;hl=en" type="application/x-shockwave-flash" />
</object></p>
<p>For my second source of frustration above, Git also provides a solution. As there is no central repository, everyone can pull and push data to each other. The verification engineer and designer can exchange files more easily, through a tracked, version controlled system, rather than the usual sideband exchanges or hacks to the check-in scripts. Git also addresses that third issue, because all of the files are local and it has been designed for performance. Network overhead isn't an issue for a <em>diff</em> or history request as you have all the data locally. Merges are similarly less painful. The claimed performance is impressive and part of the reason why I want to try Git out.</p>
<p>Now, the most glaring problem with all this is that it sounds like anarchy. There is no central organisation, check-ins can happen any time, so where did all the quality assurance go? Linus talks about the network of trust relationships in his presentation. But, you can still have acceptance tests on when you actually pull data from a particular user or set of users. You can require them to run a battery of tests before they are allowed to share their work with the rest of the project. The usual checks and balances can be put back in place for when the whole database gets reassembled, but the individual developers or groups of designers can work more efficiently in a sub-repository. Git also supports hierarchical projects that combine various blocks of code, in fact that seems to be the preferred use model. Each sub-system on a design would be a unique Git repository. It could be even broken down further and have each IP block in their own repository. The general approach that has been used in the past, with quality checks, can still be used with some changes, as a gate to when larger mergers take place. This probably requires some trusted people in the organisation to act as gatekeepers or guardians for each level, but the basic methodology shouldn't be too difficult to layer on top.</p>
<p>You can read a lot more about Git on the <a href="http://git.or.cz/">homepage,</a> including conversion documents from other common source control systems and details on the actual commands to use. Looking through the <a href="http://git.or.cz/course/svn.html">SVN conversion document</a>, the git command syntax appears a bit cleaner and generally more intuitive to me. I also played around with the <em>merge</em> and <em>diff</em> tools and they seem powerful. It was very easy to create and populate a repository, for example. I plan on using it for the next few projects I work on to get a feel for how really useful it is and where the issues are hidden.</p>
<p>Edit to add: I found this <a href="http://git.or.cz/gitwiki/GitSvnComparsion">draft version of the differences</a> between Git and Subversion quite useful.</p>

                    <div class="clear"></div>
                    <p>There are <a href="http://fivecomputers.com/git-version-control-done-right.html#disqus_thread">comments</a>.</p>
                    <div class="info">
                        <a href="http://fivecomputers.com/git-version-control-done-right.html">posted at 12:00 P</a>&nbsp;&middot;&nbsp;<a href="http://fivecomputers.com/category/26.html" rel="tag">26</a>                                                <div class="tags">
                            <a href="http://fivecomputers.com/tag/eda.html">eda</a>
                            <a href="http://fivecomputers.com/tag/software.html">software</a>
                            <a href="http://fivecomputers.com/tag/verification.html">verification</a>
                        </div>                        
                    </div>
                    <div class="clear"></div>
                </div>

                <h4 class="date">Jun 20,  2008</h4>
                <div class="post">
                    <h2 class="title">
                        <a href="http://fivecomputers.com/a-somewhat-crazy-notion.html" rel="bookmark" title="Permanent Link to &quot;a somewhat crazy notion&quot;">a somewhat crazy notion</a>
                    </h2>
                    
                    <p><a title="Death Valley, after the storm by Gordon McGregor, on Flickr" href="http://www.flickr.com/photos/mcgregorphoto/358741765/"><img height="333" width="500" alt="Death Valley, after the storm" src="http://farm1.static.flickr.com/146/358741765_9ab4eeb321.jpg" /></a>

</p>

<p>Many ideas have been whirling around in my head since being at DAC. I've been inspired to learn some new things, starting with the <a href="http://www.ovmworld.org/">Open Verification Methodology</a> but also revisiting some of the Electronic System Level tools and flows that I've worked with in the past. I'm interested in exploring visualization techniques and tools and how they might be applied to verification and design. I'd also like to learn more about a few of the more interesting formal verification tools, like <a href="http://www.onespin-solutions.com">OneSpin 360 MV</a> and maybe explore what is possible with ESL tools like <a href="http://www.bluespec.com/products/index.htm">Bluespec's SystemVerilog</a> flow or the various other similar tools that are out there.</p>

<p>I have a difficult time learning things just for the sake of it, tending to be more driven by necessity rather than idle curiosity. I've been doing some work based around a small CPU core and started getting frustrated with the way the CPU was architected. This led me to start considering designing my own CPU, just for fun. Partly as a motivation to crack open a Hennessy &amp; Patterson book that I've been meaning to read for a few years, partly to see if I can do it, partly as a vehicle to hang all those other ideas upon.</p>

<p>I've been looking around the web, browsing on <a href="http://opencores.org/">OpenCores</a> and finding humbling projects, such as <a href="http://homebrewcpu.org/">HomebrewCPU,</a> which is a Minix-compatible CPU entirely constructed from discrete gates. You can even browse the web pages that it is serving or telnet in to it! To my way of thinking, that is slightly nuts - impressive, but nuts all the same - five wire-wrapped boards to debug. My <a href="http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/m/McGregor:Gordon.html">background is in FPGAs</a> and that seems the perfect technology for this sort of exploration - I'm also thinking along the way that I might be able to play with synthesisable verification or FPGA enhanced verification/ emulation as well as possibly using this as a platform for a reconfigurable architecture. Lots of ideas, potential and possibilities. It will also give me a chance to re-engage with FPGA technologies and learn about more about the state of those tools. The various tools are getting to a fairly mature point and a simple pipelined CPU shouldn't require too much work but still be complex enough to do interesting things with.</p>

<p>I've been looking at <a href="http://www.xilinx.com">Xilinx</a> and <a href="http://www.altera.com">Altera </a>to get an understanding of their current tool flows and trying to work out language support and maturity - which would be the best option for systemVerilog, where the best simulation options are and that kind of thing. No real conclusions yet, but both have trial versions of what appears to be a complete tool chain, so I will probably drive a small example through both flows as a pipe cleaner.</p>

<p>Then of course there are the more fundamental religious issues - CISC or RISC, what ISA to use. Roll my own, pick up an already defined but open architecture, or something in between? I'm looking for suggestions in this respect - I know ARM are quite litigious when it comes to cloning their ISA, so I'll be avoiding that, but <a href="http://www.opensparc.net/">OpenSPARC</a> might well be a good option. Any other suggestions? I'm not sure if the early MIPS ISAs are cloneable without problems? Maybe I could go really back to my roots and implement a <a href="http://en.wikipedia.org/wiki/Zx81">Z80 architecture</a>. The advantage of picking on an existing ISA is that the tools come mostly for free. While porting gas and gcc to my own ISA could also be an interesting experiment and learning experience, it would probably be more of a distraction than I want.</p>

<p>I am a fan of the Python language and tend to write most of my <a href="http://gordonmcgregor.blogspot.com/2008/03/flickr-set-parser-for-gpsvisualizer.html">personal projects</a> in it. As a result, I'm intrigued by the potential for writing the core in Python, using some of the available extensions and libraries. Two packages seem to already exist, <a href="http://myhdl.jandecaluwe.com/doku.php">MyHDL</a> and <a href="http://pyhvl.sourceforge.net/">PyHVL</a>. MyHDL is Python extension to let you express parallel behaviour that can then be automatically translated to verilog or VHDL. PyHVL provides the other piece of the Python puzzle, enabling high-level verification in Python. So potentially I could do the design and verification in Python then drive through into an FPGA flow for implementation. <a href="http://www.coolverification.com/2008/06/ovm-world-summi.html">JL</a> jokingly mentioned the potential for an OVM port to Python but maybe it isn't such a crazy notion. The thing that Python is fantastic for is expressing complex ideas quickly and without a lot of fuss or housekeeping. From the verification perspective it seems to be a perfect match as I can focus more on the testing, and less on the language. I'm a bit more skeptical about using it on the design side but I think it might be worth a look.</p>

<p>To kick things off, I found the description for a <a href="http://www.csie.ntu.edu.tw/~b92029/data/EXP/mcpu-doc.pdf">minimal CPU</a> on opencores. This is a really basic 8-bit processor, 4 op codes, couple of registers and a very simple, small architecture, yet it can still do some useful function. This evening I wrote a Python ISS for it, just to prove out some ideas. Took about an hour to get a working cycle-based ISS together for the architecture. Of course, immediately the next thing you need is an assembler and that was fairly easy to put together in Python too. Nothing particularly complex, but a two pass assembler that supports labels and constants and generates code that runs on the core. I'm able to assemble and run the example greatest common divisor (Dijkstra's algorithm) described in the paper and it has given me a good indication of the direction to go. So far, my couple of hour project can assemble and execute the following code:</p>

<blockquote><p><span style="font-size: 0.8em;">start:<br />&nbsp; &nbsp; NOR allone&nbsp; &nbsp;&nbsp; &nbsp;; akku == 0<br />&nbsp; &nbsp; NOR b<br />&nbsp; &nbsp; ADD one&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; akku = -b<br /><br />&nbsp; &nbsp; ADD a&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; ; akku = a - b<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; ; Carry set when akku &gt;= 0<br />&nbsp; &nbsp; JCC neg<br /><br />&nbsp; &nbsp; STA a<br /><br />&nbsp; &nbsp; ADD allone&nbsp; &nbsp;&nbsp; &nbsp;<br />&nbsp; &nbsp; JCC end&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; A=0 ? -&gt; end, result in b<br /><br />&nbsp; &nbsp; JCC start<br /><br />neg:<br />&nbsp; &nbsp; NOR zero<br />&nbsp; &nbsp; ADD one&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;; Akku = -Akku<br /><br />&nbsp; &nbsp; STA b<br />&nbsp; &nbsp; JCC start&nbsp; &nbsp;&nbsp; &nbsp; ; carry not altered<br /><br />end:<br />&nbsp; &nbsp; JCC end<br /><br />a: 10&nbsp; ; a &amp; b are the two values to consider<br />b: 30<br /><br />allone: 0xff&nbsp; ; various constants<br />zero:&nbsp; &nbsp;0<br />one:&nbsp; &nbsp; 1</span></p></blockquote>

<p>Next step is to describe this trivial core in a synthesisable form and see how I get on running it through one or two FPGA flows. A few tests and some verification could be useful too! For FPGAs I'm much more used to the general <em>suck it and see </em>style of testing that is the norm. Synthesize, place and route and see if it works. In the last several years I've been working on much larger ASICs so have certainly seen the value of more robust verification and I think FPGA technology has probably spent too much time as the wild frontier of design robustness and testing. As this project progresses I want to explore what the best balance is for testing and how the test environments can use the FPGA to accelerate testing along the way.</p>

<p>So plenty of things up in the air but I think this could be fun.</p>

<p><br /></p>

                    <div class="clear"></div>
                    <p>There are <a href="http://fivecomputers.com/a-somewhat-crazy-notion.html#disqus_thread">comments</a>.</p>
                    <div class="info">
                        <a href="http://fivecomputers.com/a-somewhat-crazy-notion.html">posted at 12:00 P</a>&nbsp;&middot;&nbsp;<a href="http://fivecomputers.com/category/20.html" rel="tag">20</a>                                                <div class="tags">
                            <a href="http://fivecomputers.com/tag/cpu.html">cpu</a>
                            <a href="http://fivecomputers.com/tag/dac.html">dac</a>
                            <a href="http://fivecomputers.com/tag/eda.html">eda</a>
                            <a href="http://fivecomputers.com/tag/esl.html">esl</a>
                            <a href="http://fivecomputers.com/tag/software.html">software</a>
                            <a href="http://fivecomputers.com/tag/verification.html">verification</a>
                        </div>                        
                    </div>
                    <div class="clear"></div>
                </div>

                <h4 class="date">Jun 17,  2008</h4>
                <div class="post">
                    <h2 class="title">
                        <a href="http://fivecomputers.com/visual-commitment.html" rel="bookmark" title="Permanent Link to &quot;visual commitment&quot;">visual commitment</a>
                    </h2>
                    
                    <p><a title="graphic by Gordon McGregor, on Flickr" href="http://www.flickr.com/photos/mcgregorphoto/2514642239/"><img width="500" height="333" alt="graphic" src="http://farm3.static.flickr.com/2006/2514642239_13100d1a20.jpg" /></a>
</p>

<p>I've had an on again/ off again interest in visualization tools to enhance design and verification for many years. I've written log file parsers to show data in a more friendly way to enhance debug, or TCL/Tk widgets that demonstrate activity on bus ports of a SystemC AMBA switch model. Tools that at first glance might seem somewhat pointless visual trinkets can really enhance debug, by letting the brain search for patterns more easily within data. For example, with the bus switch, it was visually easy to see which bus wasn't getting any traffic, which could have been extracted from a log, but would have required more thought. Patterns of burstiness or busyness can also be seen quite easily. Similar results can usually be achieved with grep or clever regular expressions, but I find I end up having to keep a lot more data in my head, which pushes out the brainpower I might apply to actually working on the real problem.</p>

<p>Well written visualisations present the data in a more accessible way, letting you get to the problems more quickly. A good example of these from the recent DAC are a couple of OCP tools by <a href="http://www.duolog.com/">Duolog</a>. The tools present typical OCP information in a more easily interpretable way, <a href="http://www.duolog.com/products/ocp-toolkit/conductor">colouring related transactions in a log file</a>, or <a href="http://www.duolog.com/products/ocp-toolkit/tracker">showing bus bandwidth</a>. It is much simpler to trace a series of transactions this way, or find buses that are being starved or overloaded. The information could have been directly extracted from the log file by the user, but the visualisations make things easier and quicker.</p>

<p>I've been playing around with&nbsp; <a href="http://www.flashdevelop.org/">Flash</a> and also just started reading about the <a href="http://processing.org/">Processing</a> language over the weekend. Co-incidentally, I happened across these <a href="http://vis.cs.ucdavis.edu/~ogawa/codeswarm/">visualisations of version control commits</a> for several large projects, written in Processing. These give a good indication of how visualisations can show a lot of very complex data in a more accessible way. <a href="http://www.vimeo.com/1093745">The Python visualisation</a> was particularly interesting to show how few contributers there were until an explosion of contributions around the year 2000 wander on to the stage.</p>

<p>As our SoC designs keep getting larger, I believe that more accessible means to interpret the verification and design data and results will be needed, beyond just waveforms and log traces. I would be interested to see what the ebb and flow of check-ins look like for a complex, modern SoC. We tend to think that hardware design is just the same as software design by another name, but you might start to see structural differences in how the code and modifications organise themselves. </p>

<p>The Python case shows one leader, banging away on their own, suddenly joined en mass when the code base becomes popular. SoCs will also probably demonstrate Conway's Law visually, mirroring the organisational structure that put the design together. Pairs of verification and design engineers working together, sub-assemblies, clustering around organisational and functional boundaries. The vast majority of changes would be much more localised than you see in a large software project such as Python. Quite possibly other software projects fall along similar modular designs but it would be instructive to see the visualisations side by side - perhaps with the organisational (or lack of) human structure overlaid.</p>

                    <div class="clear"></div>
                    <p>There are <a href="http://fivecomputers.com/visual-commitment.html#disqus_thread">comments</a>.</p>
                    <div class="info">
                        <a href="http://fivecomputers.com/visual-commitment.html">posted at 12:00 P</a>&nbsp;&middot;&nbsp;<a href="http://fivecomputers.com/category/17.html" rel="tag">17</a>                                                <div class="tags">
                            <a href="http://fivecomputers.com/tag/dac.html">dac</a>
                        </div>                        
                    </div>
                    <div class="clear"></div>
                </div>

                <h4 class="date">Jun  6,  2008</h4>
                <div class="post">
                    <h2 class="title">
                        <a href="http://fivecomputers.com/dac-for-verification.html" rel="bookmark" title="Permanent Link to &quot;DAC for verification&quot;">DAC for verification</a>
                    </h2>
                    
                    <p>Each year, John Cooley does a great job <a href="http://www.deepchip.com/gadfly/gad060608.html">previewing the companies </a>at DAC. From that list, here's the ones that sound interesting to me.</p>

<p><strong>OneSpin</strong>'s 360MV tool does something called "gap-detection" plus timing diagrams on your design's System Verilog Assertions. (booth 625)</p>

<p><strong>Real Intent Meridian CDC</strong> for clock domain crossing verification.  Formal analysis and interfaces to simulation.<br />
(booth 2540)</p>

<p><strong>NuSym DeNibulator</strong>'s intelligent testbench"   It hunts down your hard to find coverage points and automatically tweaks your TB to reach them.  It's next gen constrained random.  (booth 379)</p>

<p><strong>Certess Certitude</strong> testbench error injection.(booth 324)</p>

<p>Another "intelligent testbench" is <strong>Mentor inFact</strong> - graphical tool that generates, grades, and then upgrades TBs.  It<br />
now drives existing e, Vera, SV, or C/C++ TBs.  Does OVM &amp; VMM.(booth 2301)</p>

<p><strong>CebaTech</strong> is showing their C2R Compiler,which takes untimed ANSI C and outputs Verilog RTL. (booth 760)</p>

<p><strong>Forte Cynthesizer v3.4</strong> (SystemC design) adds support for Power Compiler for "best-in-class area, performance, and now power results" and "management of ECOs by graphically mapping RTL back to the original SystemC design" and inter-block interfaces.(booth 1645)</p>

<p><strong>Mentor 's </strong><strong>Catapult C </strong>synth &amp; Vista ESL tools. (booth 2301)</p>

<p><strong>Carbon's Model Studio</strong> does Verilog-RTL-to-C conversion for simulation, to get early models for architectural work(booth 2467)</p>

<p><strong>Synfora Pico Extreme</strong> C synthesis tool (booth 329)</p>

<p><strong>Bluespec</strong> : "general purpose high-level synthesis &amp; simulationfor modeling, verification and implementation". (booth 2367)</p>

<p><strong>Imperas :</strong> yet-another-ISS tool, OVPsim, for embedded SW. (booth 467)</p>

<p><strong>Mirabilis VisualSim</strong> does "graphical SystemC TLM 2.0 import without any code development; and power estimation of the full system." (booth 778)</p>

<p><strong>Steve Golson's "Four Principles of Flow Engineering"</strong> DAC Tuesday at 10:30 AM, Room 206AB</p>

<p><strong>Dassault Synchronicity DesignSync</strong> Cadence data management tools. (booth 620)</p>

<p><strong>EVE ZeBu</strong> is showcasing PCIe and AXI synthesizable transactors and its System Verilog support for custom transactors.(booth 301)</p>

<p><strong>Mentor Veloce</strong> "using mixed System Verilog and SystemC based upon System Verilog DPI standard 2.0" with Nucleus embedded RTOS (booth 2301)</p>

<p><strong>Synfora Pico Extreme FPGA</strong> (booth 329)</p>

<p><strong>VeriEZ EZVerify </strong>covers you design, assertions and testbench, with added full System Verilog support this year plus VMM/OVM checking (booth 1936)</p>

<p><strong>Veritools</strong> usually has linters, code coverage and waveform viewers.  Supports SV dynamic objects. (booth 1334)</p>

<p><strong></strong></p>

<p><strong></strong></p>

<p><strong>Denali</strong> <strong>PureSpec</strong> System Verilog methodology support (OVM,VMM, AVM) in all IP blocks. (booth 1611)</p>

                    <div class="clear"></div>
                    <p>There are <a href="http://fivecomputers.com/dac-for-verification.html#disqus_thread">comments</a>.</p>
                    <div class="info">
                        <a href="http://fivecomputers.com/dac-for-verification.html">posted at 12:00 P</a>&nbsp;&middot;&nbsp;<a href="http://fivecomputers.com/category/06.html" rel="tag">06</a>                                                <div class="tags">
                            <a href="http://fivecomputers.com/tag/software.html">software</a>
                            <a href="http://fivecomputers.com/tag/verification.html">verification</a>
                        </div>                        
                    </div>
                    <div class="clear"></div>
                </div>

                <h4 class="date">May 29,  2008</h4>
                <div class="post">
                    <h2 class="title">
                        <a href="http://fivecomputers.com/about-gordon-mcgregor.html" rel="bookmark" title="Permanent Link to &quot;About Gordon McGregor&quot;">About Gordon McGregor</a>
                    </h2>
                    
                    <p>Gordon McGregor is a Verification Consultant at <a href="http://www.verilab.com">Verilab, Inc</a>, based in Austin, Texas.

Prior to that, Gordon worked for <a href="http://www.freescale.com">Freescale Semiconductor</a>, <a href="http://www.motorola.com">Motorola</a> and Pilkington Microelectronics for 7 years through various buy-outs, take-overs and spin-offs, moving from Glasgow, Scotland, to Northwich in England and finally to Austin, Texas.

</p>

<p>He received a Bachelor's degree, Master's degree and PhD from the <a href="http://www.strath.ac.uk">University of Strathclyde</a>, Scotland, in 1993, 1994 and 2005. Mostly these were in electronics, with an end bias towards dynamic reconfiguration of Field Programmable Gate Arrays (FPGAs) and methodology improvements to make dynamic reconfiguration a practical, deployable reality.

</p>

<p>His particular areas of interest are in functional verification techniques and electronic system level design along with the application of the lessons learned in the field of software engineering to the world of hardware design.</p>

                    <div class="clear"></div>
                    <p>There are <a href="http://fivecomputers.com/about-gordon-mcgregor.html#disqus_thread">comments</a>.</p>
                    <div class="info">
                        <a href="http://fivecomputers.com/about-gordon-mcgregor.html">posted at 12:00 P</a>&nbsp;&middot;&nbsp;<a href="http://fivecomputers.com/category/29.html" rel="tag">29</a>                                                <div class="tags">
                            <a href="http://fivecomputers.com/tag/.html"></a>
                        </div>                        
                    </div>
                    <div class="clear"></div>
                </div>

                <div class="post">
                    <h2 class="title">
                        <a href="http://fivecomputers.com/is-this-thing-on.html" rel="bookmark" title="Permanent Link to &quot;is this thing on...?&quot;">is this thing on...?</a>
                    </h2>
                    
                    <p>Thomas J. Watson, the president of IBM,  once famously <a href="http://en.wikipedia.org/wiki/Thomas_J._Watson">didn't say</a> that <em>I think there is a world market for maybe five computers.</em> He is still widely quoted as having said it and it is usually trotted out as a good example of why we shouldn't make predictions about the future of technology. Mainly because those predictions almost always will make us look entirely foolish. The title of this blog is based on that quote, in the hope that it'll discourage me from making too many painful statements about what I think the future of EDA and verification might be, but that's what this blog is going to be about.</p>

<p>Electronic design automation and functional verification are two pieces of the puzzle aiming to help close the design gap in the semiconductor industry. That's the gap between the amount of transistors we can put on a piece of silicon and the amount of transistors we can usefully put together to produce a working system that does something useful, in a reasonable period of time. The device physics guys have done a great job of getting well ahead of what we can usefully design. The main gap doesn't really seem to be what can be designed, though. It is what can be tested and verified to actually do what it is supposed to do.</p>

<p>There are more challenges further down the pipe too, timing closure looms ever larger as a problem, further reduction in geometries threaten the basic assumptions that let us typically ignore the nasty analog reality and pretend we are in some digital fantasy of ones and zeros. Those are all big problems or at least getting bigger, but functional verification is swallowing vast amounts of engineering time on projects right now and we seem to be getting ever further behind the curve. ( I feel already that I've made two potential <em>5 computers</em> kind of statements in just this one paragraph.) EDA tools keep promising great leaps forward, but we still seem to be seeing the same promises and not so much progress. Raising the abstraction level of the design languages, increasing the quality of the verification, more reuse and large amounts of money invested in creating IP, but largely the industry still appears to be where it was 10 years ago - just with more people working ever harder on each product.</p>

<p>The one saving grace in all this is that there is quite the demand for semiconductor devices. If you start counting up all the computers, portable devices, smart cars and embedded processors in use around your life,  you'll probably quite quickly realise you've maxed out that world market for 5 computers all on your own. In fact it is probably closer to 50 computers or computing devices in use around you. So at least the demand for products is there, even if we aren't quite sure how to design them all effectively, yet.</p>

                    <div class="clear"></div>
                    <p>There are <a href="http://fivecomputers.com/is-this-thing-on.html#disqus_thread">comments</a>.</p>
                    <div class="info">
                        <a href="http://fivecomputers.com/is-this-thing-on.html">posted at 12:00 P</a>&nbsp;&middot;&nbsp;<a href="http://fivecomputers.com/category/29.html" rel="tag">29</a>                                                <div class="tags">
                            <a href="http://fivecomputers.com/tag/eda-blogs.html">eda blogs</a>
                            <a href="http://fivecomputers.com/tag/software.html">software</a>
                            <a href="http://fivecomputers.com/tag/verification.html">verification</a>
                        </div>                        
                    </div>
                    <div class="clear"></div>
                </div>

                <div class="post">
                    <h2 class="title">
                        <a href="http://fivecomputers.com/sessions-at-dac-2008.html" rel="bookmark" title="Permanent Link to &quot;sessions at DAC 2008&quot;">sessions at DAC 2008</a>
                    </h2>
                    
                    <p>I haven't been to the <a href="http://dac.com">Design Automation Conference</a> (DAC) for several years. Last time I was there, SystemC was the hot new language on the block, ready to revolutionise the design and verification world. In the intervening years, the hype has died down a bit and SystemC has settled into a comfortable niche as a solid option for doing higher level modeling, that previously was done in a roll your own C or C++ environment. The features for modeling parallelism and communication along with structure are good enough to mean you don't need to do it all from scratch. The speed is slowly getting better, but it isn't going to change the design world. It somewhat dropped the ball by being implemented as a set of library extensions to C++, rather than an enclosed language (which would have had the potential at least to be synthesisable - something SpecC got right).</p>

<p>Now several years later, the hot new language on the block, ready to revolutionise the design and verification world is SystemVerilog. Low level enough to write hardware. Feature rich enough to support verification. An IEEE standard (that nobody quite implements). All things to all people. Maybe. Or maybe 3 distinct languages that happen to run together on one simulator - which seems closer to the reality. A step in the right direction perhaps, and certainly the current flavour of the month. OVM and VMM (verification libraries built on top of SystemVerilog) are the thing that kept coming up time and again as I looked through the DAC sessions, with an eye towards verification and system-level design. With the news that the VMM is open source, along with the already freely available OVM, perhaps the opportunity to merge to one set of libraries across the big three has some potential, if we ignore all the legacy investment that will still need to be supported.</p>

<p>These are the sessions that caught my eye at this year's DAC and that I hope to attend. I'm surprised quite how many of them overlap, so I suspect I'll be missing more than I might like. There is so much going on this year! I plan on blogging throughout the conference and sharing the interesting things I find.<br />
<h2>Monday 9th June</h2><br />
<a href="http://www.mentor.com/events/dac/schedule.cfm">Find the Toughest Bugs with Mentor Graphics 0-In Formal Verification</a><br />
<a href="http://www.doulos.com/content/events/dac08.php">Migrating to OVM for Multi-Language Verification</a><br />
<a href="http://www.dac.com/events/eventdetails.aspx?id=77-102">Gary Smith on EDA: Trends and What's Hot at DAC</a><br />
<a href="http://www.systemc.org/news/pr/view?item_key=0c33643edc9fca3fcd81281b4f0cb137b117ea71">Real World Advantages of the OSCI TLM-2.0 Standard for Model Interoperability and IP Reuse</a><br />
<h2>Tuesday 10th June</h2><br />
<a href="http://www.mentor.com/events/dac/schedule.cfm">Catapult &amp; Vista: Integrating ESL Synthesis &amp; Verification</a><br />
<a href="http://www.dac.com/events/eventdetails.aspx?id=77-15">Experiences and Advances in Formal and Dynamic Verification</a><br />
<a href="http://www.dac.com/events/eventdetails.aspx?id=77-9">Formal Verification Technology</a><br />
<a href="http://www.model.com/innovate.asp">Innovation in Verification Luncheon</a><br />
<a href="http://www.dac.com/events/eventdetails.aspx?id=77-110">Multi-processor SoCs: The Next Generation</a><br />
<a href="http://www.dac.com/events/eventdetails.aspx?id=77-13">iDesign II</a> - practical aspects of using SystemVerilog<br />
<h2>Wednesday 11th June</h2><br />
<a href="http://www.doulos.com/content/events/dac08.php">Getting Real With OVM, A True Open Source Verification Standard</a><br />
<a href="http://www.dac.com/events/eventdetails.aspx?id=77-152">Challenges on Design Complexities for Advanced Wireless Silicon Systems</a><br />
<a href="http://www.dac.com/events/eventdetails.aspx?id=77-30">Verifying Really Complex Systems: On Earth and Beyond</a><br />
<a href="http://www.dac.com/events/eventdetails.aspx?id=77-20">Wild and Crazy Ideas</a><br />
<h2>Thursday 12th June</h2><br />
<a href="http://www.dac.com/events/eventdetails.aspx?id=77-51">Advances in Verification of Abstract (pre-RTL) Models</a><br />
<a href="http://www.mentor.com/events/dac/schedule.cfm">Closing the Loop in Intelligent Testbench Automation</a><br />
<a href="http://www.dac.com/events/eventdetails.aspx?id=77-111">Your Functional Verification Roadmap: OVM, VMM, or Roll Your Own?</a><br />
<a href="http://www.dac.com/events/eventdetails.aspx?id=77-44">Formal Verification: Dude or Dud? Experiences from the Trenches</a></p>

                    <div class="clear"></div>
                    <p>There are <a href="http://fivecomputers.com/sessions-at-dac-2008.html#disqus_thread">comments</a>.</p>
                    <div class="info">
                        <a href="http://fivecomputers.com/sessions-at-dac-2008.html">posted at 12:00 P</a>&nbsp;&middot;&nbsp;<a href="http://fivecomputers.com/category/29.html" rel="tag">29</a>                                                <div class="tags">
                            <a href="http://fivecomputers.com/tag/verification.html">verification</a>
                        </div>                        
                    </div>
                    <div class="clear"></div>
                </div>

                <h4 class="date">Apr  8,  2008</h4>
                <div class="post">
                    <h2 class="title">
                        <a href="http://fivecomputers.com/time-tracking.html" rel="bookmark" title="Permanent Link to &quot;time tracking&quot;">time tracking</a>
                    </h2>
                    
                    <p><a href="http://www.flickr.com/photos/52043707@N00/368709837/"><img width="360" height="240" alt="Panamint" src="http://farm1.static.flickr.com/166/368709837_c0ff160659.jpg" /></a></p>

<p>One of the realities of doing consulting work is time tracking. I've used notebooks. I've used palm pilots, that I carried around only to track time. I've tried web based applications. Nothing quite does what I want it to do or is simple enough to keep out of the way. I've been playing around with Ruby and the Rails frameworks to come up with a solution that really does what I want. <a href="http://jexp.de/blog/archives/16-On-LEGO-Powered-Time-Tracking;-My-Daily-Column.html">Then I saw this</a>. I might have to re-think the whole thing. I'm particularly impressed with the image capture/ automatic entry.</p>

                    <div class="clear"></div>
                    <p>There are <a href="http://fivecomputers.com/time-tracking.html#disqus_thread">comments</a>.</p>
                    <div class="info">
                        <a href="http://fivecomputers.com/time-tracking.html">posted at 12:00 P</a>&nbsp;&middot;&nbsp;<a href="http://fivecomputers.com/category/04.html" rel="tag">04</a>                                                <div class="tags">
                            <a href="http://fivecomputers.com/tag/software.html">software</a>
                        </div>                        
                    </div>
                    <div class="clear"></div>
                </div>

                <h4 class="date">Mar  8,  2008</h4>
                <div class="post">
                    <h2 class="title">
                        <a href="http://fivecomputers.com/large-hadron-collider.html" rel="bookmark" title="Permanent Link to &quot;large hadron collider&quot;">large hadron collider</a>
                    </h2>
                    
                    <p><a href="http://www.flickr.com/photos/52043707@N00/2730301368/"><img src="http://farm4.static.flickr.com/3077/2730301368_3ce715dff6.jpg" height="222" width="360" alt="lhc" /></a></p>

<p>Pretty isn't it? This is the <a href="http://cmsinfo.cern.ch/outreach/">Compact Muon Solenoid</a> (or big electro-magnet) experiment tracker outer barrel from the <a href="http://public.web.cern.ch/public/en/LHC/LHC-en.html">Large Hadron Collider</a>. They are getting close to firing this up, over on the border between Switzerland and France. CERN starts the first particle beam tests this month, with the first real particle collisions happening towards the end of the year. I keep having <a href="http://www.youtube.com/watch?v=cGqroT1FZ5Y">an REM song playing</a> in the back of my head when I <a href="http://www.boston.com/bigpicture/2008/08/the_large_hadron_collider.html">look at these pictures</a>.</p>

                    <div class="clear"></div>
                    <p>There are <a href="http://fivecomputers.com/large-hadron-collider.html#disqus_thread">comments</a>.</p>
                    <div class="info">
                        <a href="http://fivecomputers.com/large-hadron-collider.html">posted at 12:00 P</a>&nbsp;&middot;&nbsp;<a href="http://fivecomputers.com/category/03.html" rel="tag">03</a>                                                <div class="tags">
                            <a href="http://fivecomputers.com/tag/.html"></a>
                        </div>                        
                    </div>
                    <div class="clear"></div>
                </div>

                <h4 class="date">Mar  6,  2008</h4>
                <div class="post">
                    <h2 class="title">
                        <a href="http://fivecomputers.com/new-companies-at-dac.html" rel="bookmark" title="Permanent Link to &quot;new companies at DAC&quot;">new companies at DAC</a>
                    </h2>
                    
                    <p>Based on the list of exhibitors and the scant information provided, these are some of new companies that appear to have a verification aspect to their products. I'll be finding out more next week on site. <a href="http://www.chipdesignmag.com/bailey/">Brian Bailey</a> has his take on DAC for Verification, over at <a href="http://www.chipdesignmag.com/">Chip Design</a> mag, that is worth a look if you are struggling to fill your schedule! There is quite an overwhelming amount of things packed in to next week.<br />
</p>

<ul>
    <li><a href="http://www.dvteclipse.com/">Amiq Consulting S.R.L.1</a> <ul><li>RTL level verification &amp; verification IP<br />
</li></ul></li></ul>

<ul><li><a href="http://www.axilica.com/">Axilica Ltd.</a><ul><li>Tools for UML modeling/simulation of HW/SW designs<br />
</li></ul></li></ul>

<ul>
    <li><a href="http://www.duolog.com/">Duolog Technologies Ltd.</a> <ul><li>Intelligent testbench, ESL verification - Socrates design environment<br />
</li></ul></li></ul>

<ul>
    <li><a href="http://www.imera.com/">Imera Systems, Inc.</a> <ul><li>Network virtualisation, remote debugging and source code access<br />
</li></ul></li></ul>

<ul>
    <li><a href="http://www.paradigm-works.com/">Paradigm Works, Inc.</a> <ul><li>Verification services company. Selling SystemVerilog FrameWorks tools<br />
</li></ul></li></ul>

<ul>
    <li><a href="http://www.satin-ip.com/">SAS Satin IP Technologies</a> <ul><li>Design reuse management flows &amp; technology. VIP lane product for IP deployment<br />
</li></ul></li></ul>

<ul>
    <li><a href="http://www.synapse-da.com/">Synapse Design Automation</a> <br /><ul><li>Design &amp; Verification services company<br />
</li></ul></li></ul>

<ul>
    <li><a href="http://www.winterlogic.com/">WinterLogic Inc.</a> <br /><ul><li>Verilog fault simulator company: Fault Manager</li></ul></li></ul>

                    <div class="clear"></div>
                    <p>There are <a href="http://fivecomputers.com/new-companies-at-dac.html#disqus_thread">comments</a>.</p>
                    <div class="info">
                        <a href="http://fivecomputers.com/new-companies-at-dac.html">posted at 12:00 P</a>&nbsp;&middot;&nbsp;<a href="http://fivecomputers.com/category/03.html" rel="tag">03</a>                                                <div class="tags">
                            <a href="http://fivecomputers.com/tag/eda-blogs.html">eda blogs</a>
                            <a href="http://fivecomputers.com/tag/verification.html">verification</a>
                        </div>                        
                    </div>
                    <div class="clear"></div>
                </div>

                <div class="clear"></div>
                <div class="pages">                
                    <a href="http://fivecomputers.com/index4.html" class="prev_page">&larr;&nbsp;Previous</a>
                    <a href="http://fivecomputers.com/index6.html" class="next_page">Next&nbsp;&rarr;</a>
                    <span>Page 5 of 6</span>
                </div>

                <div class="clear"></div>
                <div id="footer">
                    <p>
                    <a href="https://twitter.com/GordonMcGregor">Twitter @GordonMcGregor</a>
                    &middot;
                    <a class="atom" href="http://fivecomputers.com/feeds/all.atom.xml">RSS Feed</a>
                </div>
            </div>
            <div class="clear"></div>
        </div>
    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-42678190-1");
    pageTracker._trackPageview();
    } catch(err) {}</script>
<script type="text/javascript">
    var disqus_shortname = 'fivecomputers';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
    </body>
</html>